@Tutorial(time: 80) {
    @XcodeRequirement(
            title: "Xcode 13", 
            destination: "https://developer.apple.com/download/")
    
    @Intro(title: "Creating a User Interface") {
        Enhance your app with dynamic, interactive interface elements.
        
        Download the project files to begin building this project, and follow the steps below.
    }
    
    @Section(title: "ARInterfaceElement") {
        @ContentAndMedia {
            In an AR headset, every form of interaction occurs with 3D objects. Sliders, buttons, and text boxes are reimagined, with striking depth contours and shadows. Virtual computer monitors surround you with content, all controlled through telekinesis.

            Years ago, what you just read was science fiction. Now, it is reality. For the first time, any person can access interactive holograms from within their home.

            ARHeadsetKit was designed from the ground up for Google Cardboard. Hand-object interaction with minimal touchscreen input creates awesome AR headset experiences. However, the vast majority of people do not have Google Cardboard, which most likely includes you.

            To provide exceptional AR content with and without a headset, you will carefully define a user interface. Although designed for a handheld experience, your interface will translate to something amazing in headset mode.
        }
        
        @ContentAndMedia {
            To start, learn about the second data type you can render in AR. Previously, only AR objects could exist alongside the real world. Although they can form a variety of shapes, they can't represent everything. Now, you'll use interface elements.
        }
        
        @Steps {
            
        }
    }
    
    @Section(title: "Organize and Optimize") {
        @ContentAndMedia {
            The previous section showed a very easy method of rendering interface elements. However, that method is slow and repeats every frame. With just 10 elements, you can significantly impact your app's energy consumption.

            The proper way to render interface elements involves an `ARParagraphContainer`. This protocol declares how to organize interface elements and initialize them only once.
        }
        
        @Steps {
            
        }
    }
    
    @Section(title: "Static vs. Dynamic") {
        @ContentAndMedia {
            Interface elements can display two types of text: static and dynamic. Static text is hard-coded into source code, while dynamic text changes at runtime.

            2D user interface libraries like SwiftUi automatically adjust elements' size based on the length of text. However, ARHeadsetKit forces you to manually account for how many lines a paragraph spans. In this section, you will encounter a problem with text overflow, then correct it.
        }
        
        @Steps {
            
        }
    }
    
    @Section(title: "User-Centered Interface") {
        @ContentAndMedia {
            Up to this point, all interface elements had a fixed position in the real world. When the user looks away, an element will no longer be visible. However, certain controls must always be accessible.
        }
        
        @Steps {
            
        }
    }
    
    @Section(title: "Bind Button Actions") {
        @ContentAndMedia {
            When the player finishes a game, they must reset it to play again. Connect the Reset Button to its action of resetting the game. Then, create a new button with a slightly different behavior.
        }
        
        @Steps {
            
        }
    }
    
    @Section(title: "Interface Depth") {
        @ContentAndMedia {
            ARHeadsetKit lets you customize the behavior of interface elements that surround the user. Override the ``ARHeadsetKit/MainRenderer/interfaceDepth`` property of your subclass of `MainRenderer`. This will make the interface either closer or farther away from the user's head.
        }
        
        @Steps {
            
        }
    }
    
    @Section(title: "Adapt Element Size") {
        @ContentAndMedia {
            Since iPhones and iPads vary in screen size, holographic interfaces may appear larger or smaller than you designed them. Allow users to change the size and spacing of interface elements.
        }
        
        @Steps {
            
        }
    }
    
    @Section(title: "React to Interaction") {
        @ContentAndMedia {
            When the player knocks out a cube, add an occasional reaction message. The message's content is randomly chosen, so it uses dynamic text.
        }
        
        @Steps {
            
        }
    }
    
    @Section(title: "Congratulations!") {
        @ContentAndMedia {
            At the end of the game, give the player a congratulatory message.
        }
        
        @Steps {
            
        }
    }
}
