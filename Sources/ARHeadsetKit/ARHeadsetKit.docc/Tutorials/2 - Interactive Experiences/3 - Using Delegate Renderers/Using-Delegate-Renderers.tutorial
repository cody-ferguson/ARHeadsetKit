@Tutorial {
    @XcodeRequirement(
            title: "Xcode 13.1", 
            destination: "https://developer.apple.com/download/")
    
    @Intro(title: "Using Delegate Renderers") {
        Dividing your code into a renderer hierarchy helps you manage massive projects. Learn how to create a complex game while following ARHeadsetKit's design patterns.
        
<!--    Go back through and ensure all of the code listings have the correct file names.    -->
        
        Download the project files to begin building this project, and follow the steps below.
        
        @Image(source: "2-3-image-3-1-intro.jpg", alt: "A red cube appearing in the middle of blue cubes.")
    }
    
    @Section(title: "Renderer Hierarchy") {
        @ContentAndMedia {
            ARHeadsetKit uses several thousand lines of code to bring AR experiences to life. To manage all of this complexity, it divides its code among a hierarchy of objects. Source code files' names and locations reflect this hierarchy's structure.
            
            To observe this design pattern, go to "Package Dependencies" under the project navigator. Locate ARHeadsetKit and unravel the "Scene Reconstruction" directory. The following hierarchy appears:

            - SceneRenderer
                - Culling
                    - SceneCuller
                - Occlusion Testing
                    - SceneOcclusionTester
                - Reconstruction
                    - SceneMeshReducer
                    - SceneSorter
                    - SceneDuplicateRemover
                    - SceneMeshMatcher
                    - SceneTexelRasterizer
                    - SceneTexelManager

            `SceneRenderer` is the most complex delegate to the Main Renderer&mdash;it took two months to create (bookmark [this web page](https://github.com/philipturner/scene-color-reconstruction) to learn more). Its own delegates conform to a `DelegateSceneRenderer` protocol, which lets the Scene Renderer expose several properties to them. This mirrors the Main Renderer's behavior with the ``ARHeadsetKit/DelegateRenderer`` protocol.

            Examine the source code for a few minutes and search for other patterns. Every delegate holds an unowned reference to its parent (the object that creates and stores it). This prevents strong reference cycles, which cause memory leaks in Swift.

            Folders are named after a specific object, whose code they contain. Files in the same directory level have similar names, separated only by a unique suffix. You have already used this convention, by placing two files starting with "GameRenderer" in a "Game" folder.
        }
        
        @ContentAndMedia {
            In this section, you'll set up an object hierarchy, encapsulating the code for rendering cubes into a delegate to `GameRenderer`.
        }
        
        @Steps {
             @Step {
                 Place `Cube.swift` and `CubeExtensions.swift` into a new folder named "Cube".
                 
                 @Image(source: "2-3-image-1-1.png", alt: "Source code files related to Cube being located in the \"Cube\" folder.")
             }
             
             @Step {
                 Go to `Cube.swift`. In the extension to `Cube`, declare conformance to `RayTraceable`.
                 
                 @Code(name: "Cube.swift", file: "2-3-creating-code-1-1.swift", previousFile: "2-2-creating-code-5-2.swift")
             }
             
             @Step {
                 Open `CubeExtensions.swift`. In the collision method, remove the assignment to `normalObject`.
                 
                 @Code(name: "CubeExtensions.swift", file: "2-3-creating-code-1-3.swift", previousFile: "2-3-creating-code-1-2.swift")
             }
             
             @Step {
                 Go to `GameRenderer.swift`. Define the `DelegateGameRenderer` protocol, which requires that an object holds a reference to a `GameRenderer.`
                 
                 @Code(name: "GameRenderer.swift", file: "2-3-creating-code-1-4.swift", previousFile: "2-2-creating-code-1-8.swift")
             }
             
             @Step {
                 In an extension to `DelegateGameRenderer`, pass down the parent object's `renderer` and `centralRenderer` properties.
                 
                 @Code(name: "GameRenderer.swift", file: "2-3-creating-code-1-5.swift")
             }
             
             @Step {
                 Create a "Cube Renderer" folder under "Game". Add two Swift files named `CubeRenderer` and `CubeRendererExtensions`.
                 
                 @Image(source: "2-3-image-1-2.png", alt: "New files in the \"Cube Renderer\" folder.")
             }
             
             @Step {
                 In `CubeRenderer.swift`, replace the Foundation import with ARHeadsetKit. Declare a `CubeRenderer` class that conforms to `DelegateGameRenderer`.
                 
                 @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-1-6.swift", previousFile: "creating-code-template.swift")
             }
             
             @Step {
                 Add an unowned immutable reference to a `GameRenderer` and an optional cube.
                 
                 @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-1-7.swift")
             }
             
             @Step {
                 Declare the initializer required by the `DelegateGameRenderer` protocol. Initialize `gameRenderer` with the parameter passed in.
                 
                 @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-1-8.swift")
             }
             
             @Step {
                 Switch to `CubeRendererExtensions.swift`. Import ARHeadsetKit and declare an extension to `CubeRenderer`.
                 
                 @Code(name: "CubeRendererExtensions.swift", file: "2-3-creating-code-1-9.swift", previousFile: "creating-code-template.swift")
             }
             
             @Step {
                 Copy and paste the `updateResources()` method from `GameRenderer`.
                 
                 @Code(name: "CubeRendererExtensions.swift", file: "2-3-creating-code-1-10.swift")
             }
             
             @Step {
                 Open `GameRenderer.swift`. Remove the `cube` property and add an optional `CubeRenderer` instead.
                 
                 @Code(name: "GameRenderer.swift", file: "2-3-creating-code-1-11.swift", previousFile: "2-3-creating-code-1-5.swift")
             }
             
             @Step {
                 In the initializer, set the value of `cubeRenderer`.
                 
                 @Code(name: "GameRenderer.swift", file: "2-3-creating-code-1-12.swift")
             }
             
             @Step {
                 Navigate to the Game Renderer's `updateResources()` method. Replace its contents with a call to `updateResources()` on the new delegate.
                 
                 @Code(name: "GameRendererExtensions.swift", file: "2-3-creating-code-1-13.swift", previousFile: "2-2-creating-code-5-3.swift")
             }
             
             @Step {
                 Build the app and ensure no errors pop up.
             }
        }
    }
    
    @Section(title: "Randomly Generate Objects") {
        @ContentAndMedia {
            An engaging game requires some kind of goal. You will create multiple cubes at random positions around the user's room, which be knocked out to complete the game.
            
            Modify 
        }
        
        @Steps {
            @Step {
                Locate the `cube` property of `CubeRenderer`. Replace it with an empty array of cubes.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-1.swift", previousFile: "2-3-creating-code-1-8.swift")
            }
            
            @Step {
                Go to `CubeRendererExtensions.swift`. At the beginning of `updateResources()`, un-highlight all of the cubes.
                
                @Code(name: "CubeRendererExtensions.swift", file: "2-3-creating-code-2-2.swift", previousFile: "2-3-creating-code-1-10.swift")
            }
            
            @Step {
                Ray trace the `cubes` array instead of `cube`, retrieving `elementID` and `progress`.
                
                @Code(name: "CubeRendererExtensions.swift", file: "2-3-creating-code-2-3.swift")
            }
            
            @Step {
                Replace every instance of `cube` in the `if` statement with `cubes[elementID]`. Then, remove the `else` block.
                
                @Code(name: "CubeRendererExtensions.swift", file: "2-3-creating-code-2-5.swift", previousFile: "2-3-creating-code-2-4.swift")
            }
            
            @Step {
                Refactor the final statements involving `cube` into a loop, which mutates every element of `cubes`.
                
                @Code(name: "CubeRendererExtensions.swift", file: "2-3-creating-code-2-6.swift")
            }
            
            @Step {
                In `CubeRenderer.swift`, go to the required initializer. Seed the random number generator, then add a loop that iterates 10 times
                
                By default, random numbers generated by `drand48()` always appear in the exact same sequence. To make them vary between app launches, seed the generator with a unique number, such as the time.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-7.swift", previousFile: "2-3-creating-code-2-1.swift")
            }
            
            @Step {
                Create a wrapper over `drand48()` that produces a single-precision output. This will make the next steps much more concise.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-8.swift")
            }
            
            @Step {
                Declare a vector called `location`. Log to the console that the app is searching for a new cube's location.
                
                Each cube be placedfar away from every other cube's center. That way, they don't overlap and make gameplay difficult.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-9.swift")
            }
            
            @Step {
                Add a `repeat-while` statement, which ensures that `location` is 0.21 meters away from any other cube before proceeding.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-10.swift")
            }
            
            @Step {
                In the `repeat` block, generate a random position in the following bounds: ±0.3 meters for X and Y, -0.6 to 0 for Z.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-11.swift")
            }
            
            @Step {
                Declare a vector named `upDirection` and log that the app is searching for a valid up direction.
                
                The steps below describe rejection sampling, which gives each direction an equal chance to be selected. To learn more, check out [this article](http://corysimon.github.io/articles/uniformdistn-on-sphere).
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-12.swift")
            }
            
            @Step {
                Use a `repeat-while` statement similar to the previous one, but each vector component can be from -1 to 1. In addition, the `while` block ensures the length is not more than one.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-13.swift")
            }
            
            @Step {
                After ensuring the length of `upDirection` is not zero, normalize it.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-14.swift")
            }
            
            @Step {
                Finally, initialize a cube using `location` and `upDirection`, then append it to `cubes`.
                
                @Code(name: "CubeRenderer.swift", file: "2-3-creating-code-2-15.swift")
            }
            
            @Step {
                Position your phone at least 0.5 meters away from the closest wall. Then, run the app. Have fun knocking out the massive field of cubes!
                
                In the console, study the logged statements starting with "Cube 0". As more cubes were added, the volume became crowded. Cubes had to go through more attempts to find a suitable location.
                
                @Image(source: "2-3-image-2-1.png", alt: "Number of attempts to find a location increasing from 1 to 5 to 7.")
            }
        }
    }
    
    @Section(title: "Aim for a Specific Cube") {
        @ContentAndMedia {
            To make the game more difficult, only one cube at a time will participate in hand-object interaction. This cube will be colored red.
        }
        
        @Steps {
            @Step {
                Add a boolean property to `Cube`, named `isRed`. Place it directly above `isHighlighted` and initialize it to `false`.
                
                @Code(name: "Cube.swift", file: "2-3-creating-code-3-1.swift", previousFile: "2-3-creating-code-1-1.swift")
            }
            
            @Step {
                In `getObject()`, retype the code that chooses color. If the cube is red, choose light red (highlighted) or medium red (not highlighted). Otherwise, execute the code that previously existed.
                
                @Code(name: "Cube.swift", file: "2-3-creating-code-3-3.swift", previousFile: "2-3-creating-code-3-2.swift")
            }
            
            @Step {
                Navigate to the Cube Renderer's `updateResources()` method. When checking for a short tap to impact a cube, also ensure it is red.
                
                @Code(name: "CubeRendererExtensions.swift", file: "2-3-creating-code-3-4.swift", previousFile: "2-3-creating-code-2-6.swift")
            }
            
            @Step {
                Go to `GameRenderer.swift`. Add a property that fetches and stores the Cube Renderer's `cubes` array.
                
                @Code(name: "GameRenderer.swift", file: "2-3-creating-code-3-5.swift", previousFile: "2-3-creating-code-1-12.swift")
            }
            
            @Step {
                In `GameRendererExtensions.swift`, locate `updateResources()`. At the start of the method, make the first cube red.
                
                @Code(name: "GameRendererExtensions.swift", file: "2-3-creating-code-3-6.swift", previousFile: "2-3-creating-code-1-13.swift")
            }
            
            @Step {
                Run the app and try interacting with all of the cubes. Only the red one responds, leaving nothing to do once it is knocked out.
                
                @Image(source: "2-3-image-3-1.jpg", alt: "The red cube appearing in the middle of the blue cubes.")
            }
        }
    }
    
    @Section(title: "Change Selected Cube") {
        @ContentAndMedia {
            To solve the problem you just experienced, every time the player knocks out a cube, a new one must turn red. 
            
            To manage all of this complex logic, you need another delegate to `GameRenderer.`
        }
        
        @Steps {
            @Step {
                Create a "Cube Picker" folder under "Game". Add two Swift files named `CubePicker` and `CubePickerExtensions`.
                
                @Image(source: "2-3-image-4-1.png", alt: "New files in the \"Cube Picker\" folder.")
            }
            
            @Step {
                In `CubePicker.swift`, replace the Foundation import with ARHeadsetKit. Declare a class named `CubePicker`.
            }
            
            @Step {
                Conform `CubePicker` to the `DelegateGameRenderer` protocol.
            }
        }
    }

<!--  In this section, add both delegates as properties in the DelegateGameRenderer protocol extension, even though only one is needed. This is for convention. -->


}
