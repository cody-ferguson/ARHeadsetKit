@Tutorial(time: 35) {
    @XcodeRequirement(
            title: "Xcode 13", 
            destination: "https://developer.apple.com/download/")
    
    @Intro(title: "Alternative Rendering Modes") {
        Explore new workflows for rendering AR objects and speeding up your code.
        
        The process of optimizing AR objects for rendering takes a non-negligible amount of time. When preparing numerous objects one-by-one, you may encounter performance bottlenecks. To solve this problem, the ``ARHeadsetKit/CentralRenderer`` provides some alternatives to ``ARHeadsetKit/CentralRenderer/render(object:)``.
        
        Download the project files to begin building this project, and follow the steps below.
    }
    
    @Section(title: "Create Persistent Objects") {
        @ContentAndMedia {
            Summary - n/a
        }
        
        @Steps {
            @Step {
                Delete rendering code from the previous tutorial.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-1.swift", previousFile: "1-3-creating-code-4-5.swift")
            }
            
            @Step {
                Add an list of AR objects to `MyRenderer`. Name it `objects` and initialize it to an empty array.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-2.swift")
            }
            
            @Step {
                In the initializer, declare a nested function called `createShape(...)`. It takes an `ARShapeType` and three vectors&mdash;`position`, `scale`, and `upDirection`. The return value is an `ARObject`.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-3.swift")
            }
            
            @Step {
                Find a rotation going from the Y axis to `upDirection`. Normalize `upDirection` before passing it into the function.
                
                > Warning: Always normalize vectors before using them to calculate quaternions. If their length is not one, the rotation will be undefined.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-4.swift")
            }
            
            @Step {
                Return an `ARObject` initialized with `orientation` and the nested function's parameters.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-5.swift")
            }
            
            @Step {
                Add a square pyramid to the object list. Copy the function parameters exactly as they appear in the code listing. Then, write a comment saying the object's color can be changed in the settings panel.
                
                > Tip: Separate large blocks of code with comments or empty lines. Comments divide the rendered objects into related groups, making them easier to read.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-6.swift")
            }
            
            @Step {
                Append another object, by copying the code added in this step's code listing. Take note of the new shape type, and try making sense of the `position`, `scale`, and `upDirection` vectors.
                
                From this step onward, use keyboard shortcuts to copy the rendering code.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-7.swift")
            }
            
            @Step {
                Create a new section of objects, starting with a comment describing that their color can't change. Use the vectors definte in the code listing, or experiment with your own.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-8.swift")
            }
            
            @Step {
                Define a final section, with objects that have animated colors.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-9.swift")
            }
        }
    }

<!--   Next section starts with delete the previous tutorial's code   -->
<!--   The next section colors and renders them   -->
<!--   The next section introduces simd_half3   -->
<!--   Next section uses user-selected color for first two, yellow for third, green for fourth, and changing color for last 2   -->
<!--   3 steps for HSV part: declare function and 2 halves, last 2 say to just copy -->
    
    
<!--  make it like but not actually a story - some goal causes a heck ton of shapes, have to resolve a performance problem (NVM)  -->
<!--  use the special ARHeadsetKit array initializers for creating the static objects. Some will have changing color - a concept introduced here and reused in the Essence of GPGPU tutorial to space out content properly  -->

<!--   For the step about colors, tell to copy and paste the code on the right. In that step's comment, say: to learn more about HSV colors, check out https://www.rapidtables.com/convert/color/hsv-to-rgb.html -->
    
    @Section(title: "Pass an Array of Objects") {
        @ContentAndMedia {
            Instead of creating new objects every frame, you might render from a persistent array. To draw an entire list of objects at once, pass it into ``ARHeadsetKit/CentralRenderer/render(objects:)``. Doing this eliminates expensive function calls and copying operations.
        }
        
<!--   For the render(objects:) function, have statically stored objects.   -->
<!--   Create the objects in MyRenderer's initializer   -->
<!--   Make a whole bunch of AR objects with different colors and shapes, which looks cool  -->

<!--   Some objects will change red with option, none blue - color changes during updateResources() - NVM   -->

<!--   In the last step, DON'T state: "notice anything strange? The app is lagging!"              -->
        
        @Steps {
            n/a
        }
    }
    
    @Section(title: "Control the Level of Detail") {
        @ContentAndMedia {
            Round objects create the illusion of smoothness by referencing a high-resolution triangle mesh. To reduce the cost of rendering, they use as few triangles as possible without sacrificing visual quality. By calling ``ARHeadsetKit/CentralRenderer/render(objects:desiredLOD:)``, you override this behavior with a fixed level of detail (LOD).
        }
        
        @Steps {
            n/a
        }
        
<!--    Use the array from the previous section, referencing the problem of the app being laggy.    -->
<!--        -->
<!--    This can be really interactive because a small LOD makes an AR object look wierd.    -->
    }
    
    @Section(title: "Optimize Further with ARObjectGroup") {
        @ContentAndMedia {
            Sometimes, a group of similarly-sized objects will consistently appear close to each other. As a result, they will return same result during culling and LOD selection. To speed up those two tasks, an ``ARHeadsetKit/ARObjectGroup`` checks multiple objects at once, treating them as a single object.
        }
        
        @Steps {
            n/a
        }
    }
    
    @Section(title: "Opt out of Rendering") {
        @ContentAndMedia {
            Augmented reality apps use a considerable amount of processing power, so energy-intensive tasks such as rendering occur only when absolutely necessary.
           
            When the touchscreen settings panel is open, the `MainRenderer` does not draw to the screen. Delegate renderers use the ``ARHeadsetKit/DelegateRenderer/shouldRenderToDisplay`` property to detect whether their content will be presented on-screen.
        }
        
        @Steps {
            n/a
        }
    }
}
