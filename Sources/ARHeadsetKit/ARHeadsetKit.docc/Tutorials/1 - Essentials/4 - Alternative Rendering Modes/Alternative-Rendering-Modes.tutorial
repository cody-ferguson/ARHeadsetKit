@Tutorial(time: 25) {
    @XcodeRequirement(
            title: "Xcode 13", 
            destination: "https://developer.apple.com/download/")
    
    @Intro(title: "Alternative Rendering Modes") {
        Explore new workflows for rendering AR objects and speeding up your code. Coming soon!
        
        The process of optimizing AR objects for rendering takes a non-negligible amount of time. When preparing numerous objects one-by-one, you may encounter performance bottlenecks. To solve this problem, the ``ARHeadsetKit/CentralRenderer`` provides some alternatives to ``ARHeadsetKit/CentralRenderer/render(object:)``.
        
        Download the project files to begin building this project, and follow the steps below.
    }
    
<!--   Setting up the scene is its own section    -->
<!--   Instantiation of `objects` property happens first   -->
<!--   The first section shows how to make good comments, in same step as a new shape, as a tip the first time   -->

<!--   The next section colors and renders them   -->
<!--   The next section introduces simd_half3   -->
<!--   Next section uses user-selected color for first two, yellow for third, green for fourth, and changing color for last 2   -->
    
    
<!--  make it like but not actually a story - some goal causes a heck ton of shapes, have to resolve a performance problem (NVM)  -->
<!--  use the special ARHeadsetKit array initializers for creating the static objects. Some will have changing color - a concept introduced here and reused in the Essence of GPGPU tutorial to space out content properly  -->
    
    @Section(title: "Pass an Array of Objects") {
        @ContentAndMedia {
            Instead of creating new objects every frame, you might render from a persistent array. To draw an entire list of objects at once, pass it into ``ARHeadsetKit/CentralRenderer/render(objects:)``. Doing this eliminates expensive function calls and copying operations.
        }
        
<!--   For the render(objects:) function, have statically stored objects.   -->
<!--   Create the objects in MyRenderer's initializer   -->
<!--   Make a whole bunch of AR objects with different colors and shapes, which looks cool  -->

<!--   Some objects will change red with option, none blue - color changes during updateResources() - NVM   -->

<!--   In the last step, DON'T state: "notice anything strange? The app is lagging!"              -->
        
        @Steps {
            n/a
        }
    }
    
    @Section(title: "Control the Level of Detail") {
        @ContentAndMedia {
            Round objects create the illusion of smoothness by referencing a high-resolution triangle mesh. To reduce the cost of rendering, they use as few triangles as possible without sacrificing visual quality. By calling ``ARHeadsetKit/CentralRenderer/render(objects:desiredLOD:)``, you override this behavior with a fixed level of detail (LOD).
        }
        
        @Steps {
            n/a
        }
        
<!--    Use the array from the previous section, referencing the problem of the app being laggy.    -->
<!--        -->
<!--    This can be really interactive because a small LOD makes an AR object look wierd.    -->
    }
    
    @Section(title: "Optimize Further with ARObjectGroup") {
        @ContentAndMedia {
            Sometimes, a group of similarly-sized objects will consistently appear close to each other. As a result, they will return same result during culling and LOD selection. To speed up those two tasks, an ``ARHeadsetKit/ARObjectGroup`` checks multiple objects at once, treating them as a single object.
        }
        
        @Steps {
            n/a
        }
    }
    
    @Section(title: "Opt out of Rendering") {
        @ContentAndMedia {
            Augmented reality apps use a considerable amount of processing power, so energy-intensive tasks such as rendering occur only when absolutely necessary.
           
            When the touchscreen settings panel is open, the `MainRenderer` does not draw to the screen. Delegate renderers use the ``ARHeadsetKit/DelegateRenderer/shouldRenderToDisplay`` property to detect whether their content will be presented on-screen.
        }
        
        @Steps {
            n/a
        }
    }
}
