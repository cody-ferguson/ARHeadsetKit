@Tutorial(time: 35) {
    @XcodeRequirement(
            title: "Xcode 13", 
            destination: "https://developer.apple.com/download/")
    
    @Intro(title: "Alternative Rendering Modes") {
        Explore new workflows for rendering AR objects and speeding up your code.
        
        The process of optimizing AR objects for rendering takes a non-negligible amount of time. When preparing numerous objects one-by-one, you may encounter performance bottlenecks. To solve this problem, the ``ARHeadsetKit/CentralRenderer`` provides some alternatives to ``ARHeadsetKit/CentralRenderer/render(object:)``.
        
        Download the project files to begin building this project, and follow the steps below.
    }
    
    @Section(title: "Create Persistent Objects") {
        @ContentAndMedia {
            Summary - n/a
        }
        
        @Steps {
            @Step {
                Delete rendering code from the previous tutorial.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-1.swift", previousFile: "1-3-creating-code-4-5.swift")
            }
            
            @Step {
                Add an list of AR objects to `MyRenderer`. Name it `objects` and initialize it to an empty array.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-2.swift")
            }
            
            @Step {
                In the initializer, declare a nested function called `createShape()`. It takes an `ARShapeType` and three vectors&mdash;`position`, `scale`, and `upDirection`. The return value is an `ARObject`.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-3.swift")
            }
            
            @Step {
                Find a rotation going from the Y axis to `upDirection`. Normalize `upDirection` before passing it into the function.
                
                > Warning: Always normalize vectors before using them to calculate quaternions. If their length is not one, the rotation will be undefined.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-4.swift")
            }
            
            @Step {
                Return an `ARObject` initialized with `orientation` and the nested function's parameters.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-5.swift")
            }
            
            @Step {
                Add a square pyramid to the object list. Copy the function parameters exactly as they appear in the code listing. Then, write a comment saying the object's color can be changed in the settings panel.
                
                > Tip: Separate large blocks of code with comments or empty lines. Comments divide the rendered objects into related groups, making them easier to read.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-6.swift")
            }
            
            @Step {
                Append another object, by copying the code added in this step's code listing. Take note of the new shape type, and try making sense of the `position`, `scale`, and `upDirection` vectors.
                
                From this step onward, use keyboard shortcuts to copy the rendering code.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-7.swift")
            }
            
            @Step {
                Create a new section of objects, starting with a comment describing that their color can't change. Use the vectors definte in the code listing, or experiment with your own.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-8.swift")
            }
            
            @Step {
                Define a final section, with objects that have animated colors.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-1-9.swift")
            }
        }
    }
    
    @Section(title: "Pass an Array of Objects") {
        @ContentAndMedia {
            Instead of creating new objects every frame, you will sometimes render from a persistent array. To draw an entire list of objects at once, pass it into ``ARHeadsetKit/CentralRenderer/render(objects:)``.
        }
        
        @Steps {
            @Step {
                In `updateResources()`, turn `red` and `skyBlue` into half-precision vectors.
                
                Half-precision is very compact type of floating-point number. It consumes 50% less memory than single-precision and is used widely in modern GPU programming.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-1.swift", previousFile: "1-4-creating-code-1-9.swift")
            }
            
            @Step {
                Rename `color` to `userSelectedColor`.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-2.swift")
            }
            
            @Step {
                Set the first two objects' colors to `userSelectedColor`.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-3.swift")
            }
            
            @Step {
                Set the next two objects' colors to gold (70% red, 60% green, 5% blue) and light green (20% red, 85% green, 30% blue).
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-4.swift")
            }
            
            @Step {
                To make colors animate over time, you need to work with the hue-saturation-lightness (HSL) color space. Declare a function that converts HSL to red-green-blue. Set saturation to 100% by default, and lightness to 50%.
                
                Hue represents degrees on a color wheel that loops around a rainbow. Zero degrees is red, 120 degrees is green, and 240 degrees is blue.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-5.swift")
            }
            
            @Step {
                Copy and paste the new lines from the code listing, which calculate the major and minor colors.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-6.swift")
            }
            
            @Step {
                Determine whether the major and minor colors are red, green, or blue.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-7.swift")
            }
            
            @Step {
                Normalize the output and convert it to half-precision.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-8.swift")
            }
            
            @Step {
                Outside of the function, convert `numFrames` to time in seconds. Declare an `angleDegrees` variable that reaches 360 when four seconds have passed.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-9.swift")
            }
            
            @Step {
                Assign the last two objects' colors so that `hue` animates over time. For the object at index 4, decrease `saturation` to 50%.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-10.swift")
            }
            
            @Step {
                Call the new `render(objects:)` function of ``ARHeadsetKit/CentralRenderer``.
                
                @Code(name: "MyRenderer.swift", file: "1-4-creating-code-2-11.swift")
            }
            
            @Step {
                Launch the app. Watch the cuboid and octahedron's colors fluctuate over time. 
            }
        }
    }
    
    @Section(title: "Control the Level of Detail") {
        @ContentAndMedia {
            Round objects create the illusion of smoothness by referencing a high-resolution triangle mesh. To reduce the cost of rendering, they use as few triangles as possible without sacrificing visual quality. By calling ``ARHeadsetKit/CentralRenderer/render(objects:desiredLOD:)``, you override this behavior with a fixed level of detail (LOD).
        }
        
        @Steps {
            n/a
        }
        
<!--    Use the array from the previous section.    -->
<!--        -->
<!--    This can be really interactive because a small LOD makes an AR object look wierd.    -->

<!--    At the end, say to launch the app. Do the cylinder and sphere look round anymore?   -->
<!--    -->
    }
    
    @Section(title: "Optimize with ARObjectGroup") {
        @ContentAndMedia {
            Sometimes, a group of similarly-sized objects will consistently appear close to each other. As a result, they will return same result during culling and LOD selection. To speed up those two tasks, an ``ARHeadsetKit/ARObjectGroup`` checks multiple objects at once, treating them as a single object.
        }
        
<!--   Group the cylinder and octahedron into one ARObjectGroup. Group the cube and cone into another. Leave the last two out because they are not close enough.    -->
        
        @Steps {
            n/a
        }
    }
    
    @Section(title: "Opt out of Rendering") {
        @ContentAndMedia {
            Augmented reality apps use a considerable amount of processing power, so energy-intensive tasks such as rendering occur only when absolutely necessary.
           
            When the touchscreen settings panel is open, the `MainRenderer` does not draw to the screen. Delegate renderers use the ``ARHeadsetKit/DelegateRenderer/shouldRenderToDisplay`` property to detect whether their content will be presented on-screen.
        }
        
<!--    Activate a guard statement when not rendering. Call print(...) every frame to show whether it is rendering in the Xcode debug console.   -->
        
        @Steps {
            n/a
        }
    }
}
